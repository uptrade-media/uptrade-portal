/**
 * Code Generators - Creates SiteKitProvider setup and env files
 */

import fs from 'fs/promises'
import path from 'path'

// ============================================
// Types
// ============================================

interface EnvOptions {
  projectId: string
  supabaseUrl: string
  supabaseAnonKey: string
  apiKey: string
}

interface ProviderOptions {
  projectId: string
}

// ============================================
// Env File Generator
// ============================================

export async function generateEnvFile(options: EnvOptions): Promise<void> {
  const envPath = path.join(process.cwd(), '.env.local')
  
  // Check if file exists and read existing content
  let existingContent = ''
  try {
    existingContent = await fs.readFile(envPath, 'utf-8')
  } catch {
    // File doesn't exist, that's fine
  }

  // Build new env vars
  const newVars: Record<string, string> = {
    'NEXT_PUBLIC_UPTRADE_PROJECT_ID': options.projectId,
    'NEXT_PUBLIC_SUPABASE_URL': options.supabaseUrl,
    'NEXT_PUBLIC_SUPABASE_ANON_KEY': options.supabaseAnonKey,
    'UPTRADE_API_KEY': options.apiKey,
  }

  // Parse existing content
  const lines = existingContent.split('\n')
  const existingVars: Record<string, string> = {}
  const comments: string[] = []

  for (const line of lines) {
    if (line.startsWith('#') || line.trim() === '') {
      comments.push(line)
      continue
    }
    const [key, ...valueParts] = line.split('=')
    if (key) {
      existingVars[key.trim()] = valueParts.join('=').trim()
    }
  }

  // Merge vars (new vars take precedence)
  const mergedVars = { ...existingVars, ...newVars }

  // Generate new content
  let newContent = `# Uptrade Site-Kit Configuration
# Generated by @uptrade/site-kit setup wizard

# Project ID from Uptrade Portal
NEXT_PUBLIC_UPTRADE_PROJECT_ID=${newVars['NEXT_PUBLIC_UPTRADE_PROJECT_ID']}

# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=${newVars['NEXT_PUBLIC_SUPABASE_URL']}
NEXT_PUBLIC_SUPABASE_ANON_KEY=${newVars['NEXT_PUBLIC_SUPABASE_ANON_KEY']}

# Uptrade API Key (for server-side operations)
UPTRADE_API_KEY=${newVars['UPTRADE_API_KEY']}

`

  // Add any existing vars that aren't Uptrade-related
  const uptradeKeys = Object.keys(newVars)
  const otherVars = Object.entries(existingVars)
    .filter(([key]) => !uptradeKeys.includes(key))
  
  if (otherVars.length > 0) {
    newContent += '# Other Environment Variables\n'
    for (const [key, value] of otherVars) {
      newContent += `${key}=${value}\n`
    }
  }

  await fs.writeFile(envPath, newContent, 'utf-8')
}

// ============================================
// Provider Generator
// ============================================

/**
 * Safely adds an import statement to a file, respecting 'use client'/'use server' directives
 */
function addImportSafely(content: string, importStatement: string): string {
  // Check if import already exists
  const importModule = importStatement.match(/from\s+['"]([^'"]+)['"]/)?.[1]
  if (importModule && content.includes(importModule)) {
    return content
  }
  
  // Check for 'use client' or 'use server' directive at the start
  const directiveMatch = content.match(/^(['"]use (client|server)['"][\s;]*\n?)/)
  
  if (directiveMatch) {
    // Insert import AFTER the directive
    const directive = directiveMatch[0]
    const restOfFile = content.slice(directive.length)
    return directive + importStatement + '\n' + restOfFile
  } else {
    // No directive, add import at the top before other imports
    const firstImportMatch = content.match(/^(import\s+)/)
    if (firstImportMatch) {
      return importStatement + '\n' + content
    } else {
      return importStatement + '\n\n' + content
    }
  }
}

export async function generateProvider(options: ProviderOptions): Promise<void> {
  // Find the layout file
  const layoutPath = await findLayoutFile()
  if (!layoutPath) {
    throw new Error('Could not find layout.tsx file')
  }

  const content = await fs.readFile(layoutPath, 'utf-8')

  // Check if SiteKitProvider is already added
  if (content.includes('SiteKitProvider')) {
    return // Already configured
  }

  // Create backup first
  const backupPath = layoutPath + '.backup'
  await fs.writeFile(backupPath, content, 'utf-8')

  // Add import safely (respects 'use client' directive)
  const importStatement = `import { SiteKitProvider } from '@uptrade/site-kit'`
  let newContent = addImportSafely(content, importStatement)

  // Wrap children with SiteKitProvider
  // Look for {children} and wrap it
  const childrenPattern = /(\s*){children}/
  const childrenMatch = newContent.match(childrenPattern)
  
  if (childrenMatch) {
    const indent = childrenMatch[1] || '        '
    const providerWrap = `
${indent}<SiteKitProvider
${indent}  projectId={process.env.NEXT_PUBLIC_UPTRADE_PROJECT_ID!}
${indent}  supabaseUrl={process.env.NEXT_PUBLIC_SUPABASE_URL!}
${indent}  supabaseAnonKey={process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!}
${indent}  analytics={{ enabled: true }}
${indent}  engage={{ enabled: true }}
${indent}  forms={{ enabled: true }}
${indent}>
${indent}  {children}
${indent}</SiteKitProvider>`

    newContent = newContent.replace(childrenPattern, providerWrap)
  } else {
    // Try alternative pattern for layouts that use a different structure
    const bodyPattern = /(<body[^>]*>)([\s\S]*?)(<\/body>)/
    const bodyMatch = newContent.match(bodyPattern)
    
    if (bodyMatch) {
      const bodyContent = bodyMatch[2]
      const wrappedContent = `
          <SiteKitProvider
            projectId={process.env.NEXT_PUBLIC_UPTRADE_PROJECT_ID!}
            supabaseUrl={process.env.NEXT_PUBLIC_SUPABASE_URL!}
            supabaseAnonKey={process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!}
            analytics={{ enabled: true }}
            engage={{ enabled: true }}
            forms={{ enabled: true }}
          >
            ${bodyContent.trim()}
          </SiteKitProvider>
        `
      
      newContent = newContent.replace(bodyPattern, `$1${wrappedContent}$3`)
    }
  }

  await fs.writeFile(layoutPath, newContent, 'utf-8')
}

// ============================================
// Helpers
// ============================================

async function findLayoutFile(): Promise<string | null> {
  const possiblePaths = [
    'src/app/layout.tsx',
    'app/layout.tsx',
    'src/app/layout.jsx',
    'app/layout.jsx',
  ]

  for (const relativePath of possiblePaths) {
    const fullPath = path.join(process.cwd(), relativePath)
    try {
      await fs.access(fullPath)
      return fullPath
    } catch {
      continue
    }
  }

  return null
}

// ============================================
// Setup Route Generator (for visual wizard)
// ============================================

export async function generateSetupRoute(): Promise<void> {
  const routeDir = path.join(process.cwd(), 'app', '_uptrade', 'setup')
  
  // Create directory
  await fs.mkdir(routeDir, { recursive: true })

  // Create page.tsx
  const pageContent = `/**
 * Uptrade Setup Wizard
 * 
 * This route is automatically removed after setup is complete.
 * Visit /_uptrade/setup to configure Site-Kit.
 */

import { SetupWizard } from '@uptrade/site-kit/setup'

export default function SetupPage() {
  return <SetupWizard />
}
`

  await fs.writeFile(path.join(routeDir, 'page.tsx'), pageContent, 'utf-8')
}

// ============================================
// Self-Destruct
// ============================================

export async function selfDestruct(): Promise<void> {
  // Remove setup route
  const setupDir = path.join(process.cwd(), 'app', '_uptrade')
  try {
    await fs.rm(setupDir, { recursive: true, force: true })
  } catch {
    // Directory might not exist
  }

  // Remove UptradeSetup from layout if present
  const layoutPath = await findLayoutFile()
  if (layoutPath) {
    let content = await fs.readFile(layoutPath, 'utf-8')
    
    // Remove import
    content = content.replace(/import\s*{\s*UptradeSetup\s*}\s*from\s*['"]@uptrade\/site-kit\/setup['"][;\n]?/g, '')
    
    // Remove component usage
    content = content.replace(/\s*{process\.env\.NODE_ENV\s*===\s*['"]development['"]\s*&&\s*<UptradeSetup\s*\/>}\s*/g, '\n')
    content = content.replace(/<UptradeSetup\s*\/>/g, '')
    
    await fs.writeFile(layoutPath, content, 'utf-8')
  }
}

// ============================================
// Sitemap Generator
// ============================================

interface SitemapMigrationOptions {
  baseUrl: string
  existingSitemaps: Array<{
    filePath: string
    type: string
    generator?: string
  }>
  deleteExisting: boolean
}

/**
 * Generate site-kit sitemap and optionally remove existing sitemap files
 */
export async function migrateSitemap(options: SitemapMigrationOptions): Promise<{
  deleted: string[]
  created: string
}> {
  const deleted: string[] = []

  // Delete existing sitemap files if requested
  if (options.deleteExisting) {
    for (const existing of options.existingSitemaps) {
      // Skip if it's already site-kit
      if (existing.generator === 'site-kit') continue

      const fullPath = path.join(process.cwd(), existing.filePath)
      try {
        await fs.unlink(fullPath)
        deleted.push(existing.filePath)
      } catch {
        // File might not exist or be locked
      }
    }

    // Also delete next-sitemap config files
    const configFiles = [
      'next-sitemap.config.js',
      'next-sitemap.config.mjs', 
      'next-sitemap.config.ts',
    ]
    for (const config of configFiles) {
      const fullPath = path.join(process.cwd(), config)
      try {
        await fs.access(fullPath)
        await fs.unlink(fullPath)
        deleted.push(config)
      } catch {
        // File doesn't exist
      }
    }

    // Delete static sitemap.xml if it exists in public
    const staticSitemap = path.join(process.cwd(), 'public', 'sitemap.xml')
    try {
      await fs.access(staticSitemap)
      await fs.unlink(staticSitemap)
      deleted.push('public/sitemap.xml')
    } catch {
      // File doesn't exist
    }

    // Delete sitemap index if exists
    const staticSitemapIndex = path.join(process.cwd(), 'public', 'sitemap-0.xml')
    try {
      await fs.access(staticSitemapIndex)
      // Find all sitemap-N.xml files
      const publicDir = path.join(process.cwd(), 'public')
      const files = await fs.readdir(publicDir)
      for (const file of files) {
        if (file.match(/^sitemap-\d+\.xml$/)) {
          await fs.unlink(path.join(publicDir, file))
          deleted.push(`public/${file}`)
        }
      }
    } catch {
      // File doesn't exist
    }
  }

  // Generate new sitemap.ts using site-kit
  const sitemapPath = await findSitemapLocation()
  const sitemapContent = generateSitemapContent(options.baseUrl)

  await fs.mkdir(path.dirname(sitemapPath), { recursive: true })
  await fs.writeFile(sitemapPath, sitemapContent, 'utf-8')

  return {
    deleted,
    created: path.relative(process.cwd(), sitemapPath),
  }
}

/**
 * Find where to put the sitemap file
 */
async function findSitemapLocation(): Promise<string> {
  // Check if using src/app or app
  const srcApp = path.join(process.cwd(), 'src', 'app', 'sitemap.ts')
  const app = path.join(process.cwd(), 'app', 'sitemap.ts')

  try {
    await fs.access(path.join(process.cwd(), 'src', 'app'))
    return srcApp
  } catch {
    return app
  }
}

/**
 * Generate sitemap.ts content
 */
function generateSitemapContent(baseUrl: string): string {
  return `/**
 * Sitemap Generator - Powered by @uptrade/site-kit
 * 
 * Automatically discovers pages from the app directory and syncs
 * them to Portal API for SEO tracking and analytics validation.
 * 
 * Generated by Uptrade Site-Kit Setup Wizard
 */

import { createSitemap } from '@uptrade/site-kit/sitemap'

export default createSitemap({
  baseUrl: '${baseUrl}',
  
  // Optional: Exclude patterns (these are excluded by default)
  // exclude: ['/admin/*', '/api/*'],
  
  // Optional: Override priorities for specific paths
  // priorities: {
  //   '/': 1.0,
  //   '/about': 0.8,
  //   '/contact': 0.7,
  // },
  
  // Optional: Add dynamic routes not discoverable from file system
  // additionalPaths: async () => {
  //   // Example: Fetch blog posts from database
  //   // const posts = await getBlogPosts()
  //   // return posts.map(post => ({ path: \`/blog/\${post.slug}\`, priority: 0.7 }))
  //   return []
  // },
})
`
}

/**
 * Remove next-sitemap from package.json dependencies
 */
export async function removeNextSitemapDependency(): Promise<boolean> {
  const packageJsonPath = path.join(process.cwd(), 'package.json')
  
  try {
    const content = await fs.readFile(packageJsonPath, 'utf-8')
    const pkg = JSON.parse(content)
    
    let modified = false
    
    if (pkg.dependencies?.['next-sitemap']) {
      delete pkg.dependencies['next-sitemap']
      modified = true
    }
    
    if (pkg.devDependencies?.['next-sitemap']) {
      delete pkg.devDependencies['next-sitemap']
      modified = true
    }

    // Also remove from scripts if present
    if (pkg.scripts) {
      for (const [key, value] of Object.entries(pkg.scripts)) {
        if (typeof value === 'string' && value.includes('next-sitemap')) {
          delete pkg.scripts[key]
          modified = true
        }
      }
    }

    if (modified) {
      await fs.writeFile(packageJsonPath, JSON.stringify(pkg, null, 2) + '\n', 'utf-8')
    }

    return modified
  } catch {
    return false
  }
}

